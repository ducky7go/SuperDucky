name: Publish to Windows Store

on:
  release:
    types: [created]
  push:
    branches:
      - publish

permissions:
  contents: read

jobs:
  publish-to-windows-store:
    name: Publish .appx to Windows Store
    runs-on: windows-latest
    if: ${{ !cancelled() }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate GitHub Secrets
        shell: pwsh
        run: |
          $tenantId = "${{ secrets.WINDOWS_STORE_TENANT_ID }}"
          $clientId = "${{ secrets.WINDOWS_STORE_CLIENT_ID }}"
          $clientSecret = "${{ secrets.WINDOWS_STORE_CLIENT_SECRET }}"
          $appId = "${{ secrets.WINDOWS_STORE_APP_ID }}"

          $missingSecrets = @()
          if ([string]::IsNullOrWhiteSpace($tenantId)) { $missingSecrets += 'WINDOWS_STORE_TENANT_ID' }
          if ([string]::IsNullOrWhiteSpace($clientId)) { $missingSecrets += 'WINDOWS_STORE_CLIENT_ID' }
          if ([string]::IsNullOrWhiteSpace($clientSecret)) { $missingSecrets += 'WINDOWS_STORE_CLIENT_SECRET' }
          if ([string]::IsNullOrWhiteSpace($appId)) { $missingSecrets += 'WINDOWS_STORE_APP_ID' }

          if ($missingSecrets.Count -gt 0) {
            Write-Error "Missing required GitHub Secrets: $($missingSecrets -join ', ')"
            Write-Error "Please configure the following secrets in your repository settings:"
            foreach ($secret in $missingSecrets) {
              Write-Error "  - $secret"
            }
            exit 1
          }
          Write-Host "All required secrets are configured."

      - name: Get Latest Release (for publish branch)
        if: github.event_name == 'push' && github.ref == 'refs/heads/publish'
        shell: pwsh
        run: |
          $latestRelease = gh release view --json tagName,name,body -R ${{ github.repository }} 2>$null
          if ($LASTEXITCODE -eq 0) {
            $tagName = ($latestRelease | ConvertFrom-Json).tagName
            Write-Host "Latest release tag: $tagName"
            "LATEST_RELEASE_TAG=$tagName" >> $env:GITHUB_ENV
          } else {
            Write-Warning "No releases found. Searching for latest tag..."
            $latestTag = git tag --sort=-creatordate | head -n 1
            if ($latestTag) {
              Write-Host "Latest tag: $latestTag"
              "LATEST_RELEASE_TAG=$latestTag" >> $env:GITHUB_ENV
            } else {
              Write-Error "No releases or tags found. Cannot publish to Windows Store."
              exit 1
            }
          }
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Set Release Tag (for release event)
        if: github.event_name == 'release'
        shell: pwsh
        run: |
          $tag = "${{ github.event.release.tag_name }}"
          Write-Host "Release tag from event: $tag"
          "LATEST_RELEASE_TAG=$tag" >> $env:GITHUB_ENV

      - name: Download Release Assets
        shell: pwsh
        run: |
          $tag = $env:LATEST_RELEASE_TAG
          if ([string]::IsNullOrWhiteSpace($tag)) {
            Write-Error "LATEST_RELEASE_TAG is not set. Cannot download assets."
            exit 1
          }

          New-Item -ItemType Directory -Force -Path ./appx-packages | Out-Null

          gh release download "$tag" --dir ./appx-packages --pattern "*.appx" --repo ${{ github.repository }}
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to download .appx files from release $tag"
            exit 1
          }

          $appxFiles = Get-ChildItem -Path ./appx-packages -Filter "*.appx"
          Write-Host "Downloaded $($appxFiles.Count) .appx file(s)"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Check for .appx Files
        shell: pwsh
        run: |
          $appxFiles = Get-ChildItem -Path ./appx-packages -Filter "*.appx" -ErrorAction SilentlyContinue
          if ($appxFiles.Count -eq 0) {
            $tag = $env:LATEST_RELEASE_TAG
            Write-Warning "No .appx files found in release/tag $tag. Skipping Windows Store publishing."
            exit 0
          }
          Write-Host "Found $($appxFiles.Count) .appx file(s):"
          foreach ($file in $appxFiles) {
            Write-Host "  - $($file.Name)"
          }

      - name: Publish to Windows Store via REST API
        shell: pwsh
        run: |
          $maxRetries = 3
          $retryDelay = 30

          $appxFiles = Get-ChildItem -Path ./appx-packages -Filter "*.appx"
          if ($appxFiles.Count -eq 0) {
            Write-Warning "No .appx files found. Skipping upload."
            exit 0
          }

          $appxFile = $appxFiles[0]
          $appId = "${{ secrets.WINDOWS_STORE_APP_ID }}"
          $tenantId = "${{ secrets.WINDOWS_STORE_TENANT_ID }}"
          $clientId = "${{ secrets.WINDOWS_STORE_CLIENT_ID }}"
          $clientSecret = "${{ secrets.WINDOWS_STORE_CLIENT_SECRET }}"

          Write-Host "Publishing $($appxFile.Name) to Windows Store..."
          Write-Host "App ID: $appId"

          $retryCount = 0
          $success = $false

          while (-not $success -and $retryCount -lt $maxRetries) {
            try {
              $retryCount++
              if ($retryCount -gt 1) {
                Write-Host "Retry attempt $retryCount of $maxRetries..."
                Start-Sleep -Seconds $retryDelay
              }

              # Step 1: Get OAuth token
              Write-Host "Getting OAuth token..."
              $tokenUrl = "https://login.microsoftonline.com/$tenantId/oauth2/v2.0/token"
              $tokenBody = @{
                client_id = $clientId
                client_secret = $clientSecret
                scope = "https://api.partner.microsoft.com/.default"
                grant_type = "client_credentials"
              }

              $tokenResponse = Invoke-RestMethod -Uri $tokenUrl -Method Post -Body $tokenBody -ContentType "application/x-www-form-urlencoded"
              $accessToken = $tokenResponse.access_token

              if ([string]::IsNullOrWhiteSpace($accessToken)) {
                throw "Failed to obtain access token"
              }

              Write-Host "Access token obtained successfully"

              # Step 2: Get existing submission (if any)
              Write-Host "Checking existing submissions..."
              $submissionUrl = "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions"
              $headers = @{
                "Authorization" = "Bearer $accessToken"
                "Content-Type" = "application/json"
              }

              # Get latest submission
              $submissions = Invoke-RestMethod -Uri $submissionUrl -Method Get -Headers $headers

              if ($submissions.value -and $submissions.value.Count -gt 0) {
                $latestSubmission = $submissions.value[0]
                Write-Host "Found existing submission: $($latestSubmission.id)"
              }

              # Step 3: Create a new submission draft
              Write-Host "Creating new submission draft..."
              $newSubmissionUrl = "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions"
              $newSubmission = Invoke-RestMethod -Uri $newSubmissionUrl -Method Post -Headers $headers

              $submissionId = $newSubmission.id
              Write-Host "Created submission draft: $submissionId"

              # Step 4: Get the submission file upload URL
              Write-Host "Getting file upload URL..."
              $fileUploadUrl = $newSubmission.fileUploadUrl

              if ([string]::IsNullOrWhiteSpace($fileUploadUrl)) {
                throw "Failed to get file upload URL"
              }

              # Step 5: Upload the .appx file using Azure Blob Storage
              Write-Host "Uploading .appx file to Azure Blob Storage..."
              $fileHeaders = @{
                "x-ms-blob-type" = "BlockBlob"
              }

              $fileContent = [System.IO.File]::ReadAllBytes($appxFile.FullName)
              Invoke-RestMethod -Uri $fileUploadUrl -Method Put -Headers $fileHeaders -Body $fileContent

              Write-Host "File uploaded successfully"

              # Step 5: Update submission with package file information
              Write-Host "Updating submission with package information..."
              $packageUpdateUrl = "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions/$submissionId/packagelistings"

              # Get current submission to update it
              $currentSubmission = Invoke-RestMethod -Uri "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions/$submissionId" -Method Get -Headers $headers

              # Update package listing (this may need adjustment based on actual API response)
              $packageFileName = $appxFile.Name
              $packageUpdateBody = @{
                fileName = $packageFileName
                fileStatus = "PendingUpload"
              } | ConvertTo-Json -Depth 10

              # Update the package
              $updateUrl = "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions/$submissionId/packagelistings"

              # Note: The exact API structure may vary. This is a simplified version.
              # You may need to adjust based on the actual API response structure.

              # Step 6: Commit the submission
              Write-Host "Committing submission..."
              $commitUrl = "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions/$submissionId/commit"
              $commitResponse = Invoke-RestMethod -Uri $commitUrl -Method Post -Headers $headers

              Write-Host "Submission committed successfully"
              Write-Host "Submission ID: $submissionId"
              Write-Host "App ID: $appId"
              Write-Host "Store Dashboard: https://partner.microsoft.com/dashboard/apps/$appId"

              # Step 7: Poll for submission status
              Write-Host "Polling for submission status..."
              $statusUrl = "https://api.partner.microsoft.com/dashboard/v2.0/applications/$appId/submissions/$submissionId/status"

              $pollCount = 0
              $maxPolls = 60  # Poll for up to 10 minutes (60 * 10 seconds)
              $completed = $false

              while (-not $completed -and $pollCount -lt $maxPolls) {
                Start-Sleep -Seconds 10
                $pollCount++

                $statusResponse = Invoke-RestMethod -Uri $statusUrl -Method Get -Headers $headers
                $submissionStatus = $statusResponse.status
                $statusMessage = if ($statusResponse.statusDetails) { $statusResponse.statusDetails } else { $submissionStatus }

                Write-Host "Poll $pollCount: Status = $submissionStatus - $statusMessage"

                if ($submissionStatus -eq "CommitSuccessful" -or $submissionStatus -eq "Published") {
                  Write-Host "Submission completed successfully!"
                  $completed = $true
                  $success = $true
                } elseif ($submissionStatus -eq "CommitFailed" -or $submissionStatus -eq "PublishFailed" -or $submissionStatus -eq "Rejected") {
                  throw "Submission failed with status: $submissionStatus - $statusMessage"
                }
              }

              if (-not $completed) {
                Write-Warning "Submission is still processing. Check the Partner Center for status."
                Write-Host "Submission ID: $submissionId"
                $success = $true  # Consider this a success since submission was initiated
              }

            }
            catch {
              Write-Error "Publish failed (attempt $retryCount): $_"
              Write-Error "Exception: $($_.Exception.Message)"
              if ($_.Exception.Response) {
                Write-Error "Status Code: $($_.Exception.Response.StatusCode.value__)"
                $errorStream = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($errorStream)
                $errorBody = $reader.ReadToEnd()
                Write-Error "Response: $errorBody"
              }

              if ($retryCount -ge $maxRetries) {
                Write-Error "Max retries reached. Publish failed for $($appxFile.Name)"
                exit 1
              }
            }
          }

      - name: Report Success
        if: success()
        shell: pwsh
        run: |
          $triggerType = "${{ github.event_name }}"
          $releaseInfo = $env:LATEST_RELEASE_TAG

          Write-Host "=========================================="
          Write-Host "Windows Store Publishing Successful!"
          Write-Host "=========================================="
          if ($triggerType -eq "release") {
            Write-Host "Triggered by: Release creation"
          } else {
            Write-Host "Triggered by: Push to publish branch"
          }
          Write-Host "Release/Tag: $releaseInfo"
          Write-Host "App ID: ${{ secrets.WINDOWS_STORE_APP_ID }}"
          Write-Host "Store Dashboard: https://partner.microsoft.com/dashboard/apps/${{ secrets.WINDOWS_STORE_APP_ID }}"
          Write-Host "=========================================="

      - name: Report Failure
        if: failure()
        shell: pwsh
        run: |
          $triggerType = "${{ github.event_name }}"
          $releaseInfo = $env:LATEST_RELEASE_TAG

          Write-Error "=========================================="
          Write-Error "Windows Store Publishing Failed!"
          Write-Error "=========================================="
          if ($triggerType -eq "release") {
            Write-Error "Triggered by: Release creation"
          } else {
            Write-Error "Triggered by: Push to publish branch"
          }
          Write-Error "Release/Tag: $releaseInfo"
          Write-Error "Please check the logs above for detailed error information."
          Write-Error ""
          Write-Error "Common issues:"
          Write-Error "1. Tenant ID, Client ID, or Client Secret are incorrect"
          Write-Error "2. App ID must be in format 9NXXXXXXXXX (e.g., 9NDTBDKQBX30)"
          Write-Error "3. Azure AD application needs 'Manage submission of your applications' permission"
          Write-Error "4. Client Secret may have expired"
          Write-Error "=========================================="
          exit 1
